/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/curious_skeleton/scene.gltf 
Author: J1G4R (https://sketchfab.com/jigar6102021)
License: SKETCHFAB Standard (https://sketchfab.com/licenses)
Source: https://sketchfab.com/3d-models/curious-skeleton-757d9863b3504a75a439b2b99a530454
Title: Curious skeleton
*/

import React, { useMemo } from "react";
import { useGraph, useFrame } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";

// Wave shader code to inject into physical material
const waveVertexModifier = `
  // Wave functions
  float waveDisplacement(vec2 uv, float time) {
    float wave1 = sin(uv.x * 4.0 + uv.y * 2.0 + time * 1.8) * 0.03;
    float wave2 = sin(uv.y * 3.5 - uv.x * 1.5 + time * 1.35) * 0.025;
    float wave3 = sin((uv.x + uv.y) * 3.0 + time * 2.25) * 0.02;
    return (wave1 + wave2 + wave3) / 3.0;
  }
`;

const waveFragmentModifier = `
  // Wave functions for normal modification
  float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
  }
  
  float smoothNoise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = noise(i);
    float b = noise(i + vec2(1.0, 0.0));
    float c = noise(i + vec2(0.0, 1.0));
    float d = noise(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }
  
  float fractalNoise(vec2 p) {
    float value = 0.0;
    float amplitude = 0.5;
    for (int i = 0; i < 3; i++) {
      value += amplitude * smoothNoise(p);
      p *= 2.0;
      amplitude *= 0.5;
    }
    return value;
  }
  
  float wavePattern(vec2 uv, float time) {
    float wave1 = sin(uv.x * 4.0 + uv.y * 2.0 + time * 1.8) * 0.5 + 0.5;
    float wave2 = sin(uv.y * 3.5 - uv.x * 1.5 + time * 1.35) * 0.5 + 0.5;
    float wave3 = sin((uv.x + uv.y) * 3.0 + time * 2.25) * 0.5 + 0.5;
    float combinedWaves = (wave1 + wave2 + wave3) / 3.0;
    float n = fractalNoise(uv * 3.0 + vec2(time * 0.45, time * 0.375));
    return combinedWaves * 0.7 + n * 0.3;
  }
  
  vec3 waveNormalModifier(vec2 uv, float time, vec3 originalNormal) {
    // Create normal perturbation based on wave gradient
    float eps = 0.01;
    vec2 gradient = vec2(
      wavePattern(uv + vec2(eps, 0.0), time) - wavePattern(uv - vec2(eps, 0.0), time),
      wavePattern(uv + vec2(0.0, eps), time) - wavePattern(uv - vec2(0.0, eps), time)
    ) * 0.8;
    
    // Create tangent space
    vec3 tangent = normalize(cross(originalNormal, vec3(1.0, 0.0, 0.0)));
    if (length(tangent) < 0.01) {
      tangent = normalize(cross(originalNormal, vec3(0.0, 1.0, 0.0)));
    }
    vec3 bitangent = normalize(cross(originalNormal, tangent));
    
    return normalize(originalNormal + tangent * gradient.x + bitangent * gradient.y);
  }
`;

export default function CuriousSkeleton(props) {
  const group = React.useRef();
  const { scene, animations } = useGLTF("/curious_skeleton/scene.gltf");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions } = useAnimations(animations, group);

  // Track opacity for fade-in animation
  const fadeInStartTime = React.useRef(Date.now());

  // Create physical material with wave effects injected via shader modification
  const obsidianMaterial = useMemo(() => {
    const material = new THREE.MeshPhysicalMaterial({
      color: "#000000",
      roughness: 0.1,
      metalness: 0,
      clearcoat: 0,
      clearcoatRoughness: 0.03,
      reflectivity: 0.1,
      envMapIntensity: 2.5,
      ior: 1.25,
      transmission: 0.05,
      thickness: 0.5,
      emissive: "#2f2f3f",
      emissiveIntensity: 0.4,
      transparent: true,
      opacity: 0,
    });

    // Add time uniform for animation - store reference for updates
    const timeUniform = { value: 0 };
    material.userData.uTime = timeUniform;

    // Inject wave effects into the shader using onBeforeCompile
    material.onBeforeCompile = (shader) => {
      // Add time uniform - use the stored reference
      shader.uniforms.uTime = timeUniform;

      // Inject wave functions, uniform, and varying declarations into vertex shader
      shader.vertexShader =
        `
          uniform float uTime;
          varying vec2 vUv;
        ` +
        waveVertexModifier +
        shader.vertexShader;

      // Set vUv in vertex shader after UV is processed
      shader.vertexShader = shader.vertexShader.replace(
        "#include <uv_vertex>",
        `
          #include <uv_vertex>
          vUv = uv;
        `
      );

      // Modify vertex position with wave displacement after UV is set
      shader.vertexShader = shader.vertexShader.replace(
        "#include <project_vertex>",
        `
          float displacement = waveDisplacement(uv, uTime);
          transformed += objectNormal * displacement;
          #include <project_vertex>
          `
      );

      // Inject wave functions, uniform, and varying declarations into fragment shader
      shader.fragmentShader =
        `
          uniform float uTime;
          varying vec2 vUv;
        ` +
        waveFragmentModifier +
        shader.fragmentShader;

      // Declare wave variable once at the start of main function
      shader.fragmentShader = shader.fragmentShader.replace(
        "void main() {",
        `
          void main() {
            float wave = wavePattern(vUv, uTime);
        `
      );

      // Modify normal with wave pattern before lighting calculations
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <normal_fragment_maps>",
        `
          #include <normal_fragment_maps>
          normal = waveNormalModifier(vUv, uTime, normal);
          `
      );

      // Modify roughness based on wave pattern - make wave areas rougher (darker)
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <roughnessmap_fragment>",
        `
          #include <roughnessmap_fragment>
          // Make wave areas rougher (less reflective = darker)
          roughnessFactor = mix(roughnessFactor * 0.3, roughnessFactor * 1.5, wave);
          `
      );

      // Reduce emissive in wave areas to make them darker
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <emissivemap_fragment>",
        `
          #include <emissivemap_fragment>
          // Darken wave areas by reducing emissive
          totalEmissiveRadiance *= (1.0 - wave * 0.5);
          `
      );

      // Darken color in wave areas
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <color_fragment>",
        `
          #include <color_fragment>
          // Make wave areas darker
          vec3 waveDarkness = mix(vec3(0.0, 0.0, 0.0), vec3(-0.1, -0.1, -0.1), wave * 0.4);
          diffuseColor.rgb += waveDarkness;
          `
      );
    };

    return material;
  }, []);

  // Animate the wave effect and fade-in
  useFrame((state) => {
    // Update wave time uniform
    if (obsidianMaterial.userData.uTime) {
      obsidianMaterial.userData.uTime.value = state.clock.elapsedTime;
      // Force shader update if uniform exists
      if (obsidianMaterial.uniforms && obsidianMaterial.uniforms.uTime) {
        obsidianMaterial.uniforms.uTime.value = state.clock.elapsedTime;
      }
    }

    // Animate fade-in
    if (obsidianMaterial.opacity < 1) {
      const elapsed = (Date.now() - fadeInStartTime.current) / 1000; // Convert to seconds
      const fadeDuration = 1.5; // 1.5 seconds fade-in
      obsidianMaterial.opacity = Math.min(elapsed / fadeDuration, 1);
    }
  });
  return (
    <group ref={group} {...props} dispose={null} position={[0, -3, 4.5]}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="root">
            <group name="GLTF_SceneRootNode" rotation={[Math.PI / 2, 0, 0]}>
              <group name="RootNode0_0" scale={0.01}>
                <group name="skeletal3_3">
                  <group name="GLTF_created_0">
                    <primitive object={nodes.GLTF_created_0_rootJoint} />
                    <group name="skeleton2_2_correction">
                      <group name="skeleton2_2" />
                    </group>
                    <skinnedMesh
                      name="Object_118"
                      geometry={nodes.Object_118.geometry}
                      material={obsidianMaterial}
                      skeleton={nodes.Object_118.skeleton}
                    />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/curious_skeleton/scene.gltf");
